<html>
<canvas id="canvas" style='position:absolute;top:0px;left:0px;'></canvas>

<script>
window.onload = function(){
	var canvas = document.getElementById("canvas");
	var context = canvas.getContext('2d');

	canvas.width = document.body.clientWidth;
	canvas.height = document.body.clientHeight;
	drawWindow(context);

	window.onresize = function(){
		canvas.width = document.body.clientWidth;
		canvas.height = document.body.clientHeight;
		drawWindow(context);
	}

	var vertices = [];
	var segments = [];
	for(var i = 0; i < 10; i++){
		for(var j = 0; j < 10; j++){
			vertices.push(new vertex(i * 100, j * 100));
		}
	}

	var mouseIsDown = false;
	var dragOffset = {};
	dragOffset.x = 0;
	dragOffset.y = 0;

	var editor = new Editor(vertices, segments);

	canvas.onmousedown = editor.mdown;
	canvas.onmouseup = editor.mup;
	canvas.onmousemove = editor.mmove;

	renderContext = new RenderContext(context, vertices, segments, editor);
	window.requestAnimationFrame(function(delta){
			renderContext.render(renderContext, editor);
			});
}

</script>

<script>
drawWindow = function(context){
	context.fillStyle = "#f0f0f0"; 
	context.fillRect(0, 0, canvas.width, canvas.height);
	drawGrid(context);
};

drawGrid = function(context){
	for (var x = 0.5; x < canvas.width; x += 10) {
		context.moveTo(x, 0);
		context.lineTo(x, canvas.height);
	}

	for (var y = 0.5; y < canvas.height; y += 10) {
		context.moveTo(0, y);
		context.lineTo(canvas.width, y);
	}

	context.strokeStyle = "#ddd";
	context.stroke();	
}

var vertex = function(xpos, ypos){
	this.pos = {x:xpos, y:ypos};
	this.color = "#0000ff";
	this.pickedColor = "#00ff00";
	this.chainedColor = "#00ffff";
	this.currentColor = this.color;
	this.r = 7;
	this.connected = [];
};

var RenderContext = function(context, vertices, segments, editor){
	this.context = context;
	this.segments = segments;
	this.vertices = vertices;
	this.editor = editor;
};

RenderContext.prototype.render = function(renderContext, editor){
	var verts = renderContext.vertices;
	var segs = renderContext.segments;
	var context = renderContext.context;
	
	drawWindow(context);

	// draw vertices
	for(var i = 0; i < verts.length; i++){
		context.fillStyle = verts[i].currentColor;
		context.strokeStyle = verts[i].currentColor;
		context.beginPath();
		context.arc(verts[i].pos.x, verts[i].pos.y, verts[i].r, 0, Math.PI*2, true);
		context.stroke();
	}

	// draw segments
	for(var j = 0; j < segs.length; j++){
		pt1 = segs[j][0];
		pt2 = segs[j][1];

		context.strokeStyle = "#00ff00";
		context.beginPath();
		context.moveTo(pt1.pos.x, pt1.pos.y);
		context.lineTo(pt2.pos.x, pt2.pos.y);
		context.stroke();
	}

	if(editor.dragging && editor.selected == 0){
		context.beginPath();
		context.strokeStyle = "#000ddd";
		context.lineWidth = "1";
		context.rect(editor.dragStart.x, editor.dragStart.y, editor.gsPos.x - editor.dragStart.x, editor.gsPos.y - editor.dragStart.y);
		context.stroke();
	}
	
	// go to the next frame
	window.requestAnimationFrame(function(){
			renderContext.render(renderContext, editor);
			});
};

var Editor = function(vertices, segments){
	this.vertices = vertices;
	this.segments = segments;
	this.dragOffset = {};
	this.dragOffset.x = 0;
	this.dragOffset.y = 0;

	this.position = {};
	this.position.x = 0;
	this.position.y = 0;

	this.mouseIsDown = false;
	this.mdown = this.mouseDown.bind(this);
	this.mup = this.mouseUp.bind(this);
	this.mmove = this.mouseMove.bind(this);

	// dragging logic
	this.dragging = false;
	this.dragTolerance = 4;
	this.dragStart = {};
	this.dragStart.x = 0;
	this.dragStart.y = 0;

	// group select logic
	this.gsPos = {};
	this.gsPos.x = 0;
	this.gsPos.y = 0;

	// selected logic
	// TODO change from 0 to undef or some other definition
	this.selected = 0;
	this.selectedChained = [];
};

Editor.prototype.mouseDown = function(e){
	this.dragStart.x = e.x;
	this.dragStart.y = e.y;
	
	this.mouseIsDown = true;
};

Editor.prototype.mouseUp = function(e){
	// if the user isn't dragging when they release the button, assume that it's a click
	
	if(!this.dragging){
		this.mouseClick(e);
	} else {
	    
		// else, stop dragging a vertex
		if(this.selected == 0){
			for(var i = 0; i < this.selectedChained.length; i++){
				this.selectedChained[i].currentColor = this.selectedChained[i].color;
			}
		
			this.selectedChained = [];
			this.selected = 0;
			for(var i = 0; i < this.vertices.length; i++){
				var vtx = this.vertices[i];
				var tl = {x:Math.min(this.dragStart.x, this.gsPos.x), y:Math.min(this.dragStart.y, this.gsPos.y)};
				var br = {x:Math.max(this.dragStart.x, this.gsPos.x), y:Math.max(this.dragStart.y, this.gsPos.y)};
				
				if(vtx.pos.x < br.x && vtx.pos.x > tl.x && vtx.pos.y > tl.y && vtx.pos.y < br.y){
					if(this.selected == 0){
						this.selected = vtx;
						this.selected.currentColor = this.selected.pickedColor;
					} else {
						this.selectedChained.push(vtx);
						vtx.currentColor = vtx.chainedColor;
					}
				}
			}
		}
	}

	// manage state (not dragging anymore since button was released)
	this.dragging = false;
	this.mouseIsDown = false;
};

Editor.prototype.mouseClick = function(e){
	// shift is the main modifier in the program
	if(e.shiftKey){
		// if there wasn't a vertex picked in mousedown, create a new vertex
		if(this.selected == 0){
			this.vertices.push(new vertex(e.x, e.y));
		} else {
			// if there's a selected vertex, try picking for another vertex to make a segment
			linePt = this.pick({x:e.x, y:e.y});
			if(linePt != 0){
				if(this.selected.connected.indexOf(linePt) == -1){
					this.segments.push([this.selected, linePt]);
					this.selected.connected.push(linePt);
					linePt.connected.push(this.selected);
				} else {
					this.selected.connected.splice(this.selected.connected.indexOf(linePt), 1);
					linePt.connected.splice(linePt.connected.indexOf(this.selected), 1);
					for(var i = 0; i < this.segments.length; i++){
						if((this.segments[i][0] == this.selected || this.segments[i][0] == linePt) && (this.segments[i][1] == this.selected || this.segments[i][1] == linePt)){
							this.segments.splice(i, 1);
						}
					}
					
				}
			}
		}
	} else {
		// reset the color of the last-picked vertex, since it's being unselected
		if(this.selected != 0){
			this.selected.currentColor = this.selected.color;
			for(var i = 0; i < this.selectedChained.length; i++){
				this.selectedChained[i].currentColor = this.selectedChained[i].color;
			}
			this.selectedChained = [];
		}

		// try picking for a vertex
		this.selected = this.pick({x:e.x, y:e.y});

		// there's a newly selected vertex now
		if(this.selected != 0){
			// select chain of vertices
			
			if(e.ctrlKey){
				traversed = [];
				// TODO replace with 2 stacks instead of a queue
				toTraverse = [this.selected];
				while(toTraverse.length != 0){
					//log(["traversed:", traversed, "toTraverse:", toTraverse]);
					current = toTraverse.shift();
					if(traversed.indexOf(current) == -1){
						traversed.push(current);
						for(var i = 0; i < current.connected.length; i++){
							if(traversed.indexOf(current.connected[i]) == -1 && toTraverse.indexOf(current.connected[i] == -1)){
								toTraverse.push(current.connected[i]);
								log(["added traverse", current.connected[i].pos.x + ", " + current.connected[i].pos.y]);
							}
						}
					}
				}

				for(var i = 0; i < traversed.length; i++){
					traversed[i].currentColor = traversed[i].chainedColor;
				}
				
				traversed.splice(traversed.indexOf(this.selected), 1);
				
				this.selectedChained = traversed;
			}
			this.selected.currentColor = this.selected.pickedColor;
		} 
	}
};

Editor.prototype.mouseMove = function(e){
	// update position of a vertex being dragged
	if(this.dragging && this.selected != 0){
		dx = this.selected.pos.x - e.x;
		dy = this.selected.pos.y - e.y;
		this.selected.pos.x = e.x;
		this.selected.pos.y = e.y;
		for(var i = 0; i < this.selectedChained.length; i++){
			this.selectedChained[i].pos.x -= dx;
			this.selectedChained[i].pos.y -= dy;
		}
	}

	// dragging logic
	if(this.mouseIsDown){
		// start dragging if not already dragging and the mouse has moved more than a certain
		// tolerated distance to register as a click instead
		if(!this.dragging && Math.sqrt( Math.pow(this.dragStart.x - e.x, 2) + Math.pow(this.dragStart.y - e.y, 2)) > this.dragTolerance){
			this.dragging = true;
			
			// grab this so we can swap out the selected vertex into selectedChained if necessary
			var tmp = this.selected;
			
			// try picking a vertex to drag
			this.selected = this.pick(this.dragStart);
			if(this.selected != 0){
				// if the picked vertex isn't the currently selected vertex, swap them out
				if(this.selectedChained.indexOf(this.selected) != -1){
					this.selectedChained.splice(this.selectedChained.indexOf(this.selected), 1);
					this.selectedChained.push(tmp);
					this.selected.currentColor = this.selected.pickedColor;
					tmp.currentColor = tmp.chainedColor;
				}
			} else {
				tmp.currentColor = tmp.color;
				for(var i = 0; i < this.selectedChained.length; i++){
					this.selectedChained[i].currentColor = this.selectedChained[i].color;
				}
			}
		}
		
		if(this.dragging){
			// group selection position
			this.gsPos.x = e.x;
			this.gsPos.y = e.y;
			
			// don't remember why this is here
			/*
			if(this.selected == 0){
				this.selected.currentColor = this.selected.color;
				for(var i = 0; i < this.selectedChained.length; i++){
					this.selectedChained[i].currentColor = this.selectedChained[i].color;
				}
				this.selectedChained = [];
				this.selected = 0;
				this.selected = 0;
			}
			*/
		}
	}
	return false;
};

// pick a vertex on click
Editor.prototype.pick = function(pos){
	var picked = 0;
	this.vertices.forEach(function(el, i, arr){
		if(Math.sqrt( Math.pow(pos.x - el.pos.x, 2) + Math.pow(pos.y - el.pos.y, 2)) < 2 * el.r ){
			picked = el;
			return;
		}
	});
	log(['Picked:', picked]);
	return picked;
};

var log = function(args){
	for(var i = 0; i < args.length; i++){
		console.log(args[i]);
	}
	console.log("");
}
</script>

</html>
